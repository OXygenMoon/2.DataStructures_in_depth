---
title: 数据结构与算法之美
date: 2021-02-10 15:10:00
tags:
- 数据结构
categories:
- 数据结构
notshow: false
---

<p align='center'>
<a href="https://oxygenpanda.github.io/" target="_blank"><img alt="Website" src="https://img.shields.io/badge/博客-劳振煜的知識倉儲-faf2f2.svg?style=flat-square&logo=Blogger"></a>
<a href="https://www.github.com/OXygenPanda" target="_blank"><img src="https://img.shields.io/badge/Github-@劳振煜-f3e1e1.svg?style=flat-square&logo=GitHub"></a>
<a href="https://i.loli.net/2020/11/11/SBZ2mFJGKLjUtTO.jpg" target="_blank"><img src="https://img.shields.io/badge/微信-@OXygen-f1d1d1.svg?style=flat-square&logo=WeChat"></a>



# 前言

本文记录了数据结构与算法之美的学习笔记, 记录了一些自己觉得比较重要的点.

<!--more-->



# 05 | 数组

## 主题 : 为什么很多编程语言中数组都是从0开始编号?

------

数组是一种线性表数据结构, 用一组连续的内存空间, 来存储一组具有相同类型的数据.

```cpp
a[i]_address = base_address + i * data_type_size
```

数组的连续存储, 相较于链表的非连续存储的优点 : 支持随机访问, 随机访问时间复杂度为 O(1), 有序情况下, 查找的时间复杂度为 O(logN); 插入删除的时间复杂度为 O(N)

### 插入

在数组不有序, 且对排序无所谓的情况下, 在某个位置插入元素, 可以将该位置的元素赋值到数组末尾, 再将元素赋值到该位.

### 删除

删除元素时, 可以用数组来记录删除的索引值, 当数组空间不够用时, 触发删除操作.

### STL

STL中的 vector 已经很好地把数组的一些存在的问题解决了, 细节给隐藏起来了, 并且支持扩容, 但是需要注意的是, 如果提前知道元素个数, 应当初始化长度.



----

# 06 07 | 链表

## 主题 : 如何实现LRU缓存淘汰算法?

------

缓存大小有限, 当缓存被用满时, 哪些数据应该被清理出去, 哪些数据应当被保留? 有以下三种淘汰策略 :

-   先进先出策略 FIFO
-   最少使用策略 LFU
-   最近最少使用策略 LRU

解决办法 :

1.  维护一个有序的单链表
2.  遍历链表来查询访问的数据
3.  如果此数据在链表中存在, 将原来的位置删除, 把数据插入在链表头
4.  如果此数据在链表中不存在, 如果缓存未满, 把数据插入在链表头; 如果缓存已满, 把链表尾部节点删除, 把数据插入在链表头
5.  此时, 缓存访问的时间是 O(N)
6.  引入 hashtable 记录每一个数据在链表中的位置, 可以将缓存访问的时间降低到  O(1)

------

## 链表

链表分为 : 单链表, 双向链表, 循环链表.

链表是非连续存储的线性表, 插入和删除的时间复杂度为 O(1), 不支持随机访问, 查找的时间复杂度为 O(N)

------

## 主题 : 如何轻松写出正确的链表代码?

技巧一 : 理解指针或者引用的含义

技巧二 : 警惕指针丢失和内存泄漏

技巧三 : 利用哨兵简化实现难度

技巧四 : 留意边界条件处理

可能存在的边界条件 :

1.  链表为空;
2.  只包含一个节点;
3.  只包含两个节点;
4.  处理头结点和尾结点.

技巧五 : 举例画图

技巧六 : 多写多练


----

# 08 | 栈

## 主题 : 如何实现浏览器的前进和后退功能

------

点完页面 a-b-c 之后, 点击浏览器的后退按钮, 可以看到页面 a 和页面 b.

后退到 a 后, 前进可以到达 b 和 c.

但是如果点击了 d, 就再也看不到 c 了.

------

## 栈

栈是一种操作受限的线性表, 只允许在一端插入和删除数据.

栈根据底层实现可以分为 : 顺序栈 和 链式栈.

### 应用

函数调用栈 : 操作系统给每一个线程分配一块独立的内存空间, 栈空间用来存储函数调用时的临时变量. 每进入一个函数, 临时变量作为一个栈帧入栈, 函数执行完, 函数对应的栈帧出栈.

波兰表达式 : 计算前缀表达式和后缀表达式时, 需要使用栈来存储符号和数字.

括号匹配

浏览器前进后退 : 两个栈, 点击页面放入第一个栈中, 点击后退时, 第一个栈的顶放入第二个栈, 点击前进时, 第二个栈的顶放入第一个栈, 再次点击新页面时, 放入第一个栈, 清空第二个栈.



----

# 09 | 队列

## 主题 : 队列在线程池等有限资源池中的应用

------

CPU资源是有限的, 任务的处理速度与线程个数并不是线性正相关.

过多的线程反而会导致 CPU 频繁切换, 处理性能下降.

>   当我们向固定大小的线程池请求一个线程时, 如果没有空闲资源时, 应该是拒绝服务还是排队请求呢?

解决方式 :

1.  采用非阻塞的方式, 遇到没有线程的情况, 直接拒绝服务;
2.  采用阻塞的方式, 遇到没有线程的情况, 就进行排队, 但是应该选择顺序队列还是链式队列呢? :
    1.  链式队列 : 无限排队, 可能会导致过多的请求排队等待, 会导致响应时间过长. 所以不合适.
    2.  顺序队列 : 请求排队数量受限, 对于响应时间敏感的系统来说, 较为合适.

------

## 队列

队列同样也是一种操作受限的数据结构, 固定端输入和另一端输出

队列根据底层数据结构, 可以分为 顺序队列 和 链式队列.

队列输出可以在入队的时候集中搬移.

### 应用

阻塞队列 : 在普通队列的基础上, 增加阻塞的功能, 在队列空的时候, 取操作会被阻塞; 在队列满的时候, 放操作会被阻塞.      ← 生产者 - 消费者模型

并发队列 : 线程安全的队列叫并发队列, 在 push() 和 pop() 上加锁, 但是锁粒度大并发度就会低, 同一时刻允许一个存或者取操作, 基于数组的循环队列, 利用CAS原子操作, 可以实现高效的并发队列.

分布式系统中的消息队列

----

# 10 | 递归

## 主题 : 如何用三行代码找到 "最终推荐人"

用户 A 推荐用户 B 注册, 用户 B 推荐用户 C 注册.

用户 C 的最终推荐人是用户 A.

------

## 递归

一种应用广泛的编程技巧.

递归三个条件 :

1.  一个问题的解可以分解为几个子问题的解;
2.  子问题和原问题的求解思路相同;
3.  存在递归终止条件.

### 堆栈溢出

调用一个函数时, 将临时变量作为栈帧压入到内存栈中, 等函数执行完成返回时, 出栈.

一般, 系统栈或者虚拟机栈的空间都不大.

如果递归求解的规模巨大, 调用层次更深, 会有堆栈溢出的风险.

### 递归调试

1.  打印日志发现, 递归值.
2.  结合条件断点进行调试.

----

# 11 - 14 | 排序

## 主题 : 为什么插入排序比冒泡排序更受欢迎?

------

------

## 排序

常见的排序 : 冒泡, 插入, 选择, 归并, 快速, 堆, 计数, 基数, 桶排序.

其他的排序 : 猴子排序, 睡眠排序, 面条排序.

按照时间复杂度来划分 :

-   O(N^2) : 冒泡排序, 选择排序, 插入排序
-   O(NlogN) : 快速排序, 归并排序, 堆排序
-   O(N) : 桶排序, 计数排序, 基数排序

原地排序 : 空间复杂度为O(1)的排序算法

稳定性 : 数值相等的元素, 排序后相对位置不变

### 冒泡排序 | 选择排序 | 插入排序

这三种排序都是原地排序.

冒泡排序 : 原地排序, 稳定, O(N^2)

插入排序 : 原地排序, 稳定, O(N^2)

选择排序 : 原地排序, 非稳定, O(N^2)

### 归并排序 | 快速排序

适合大规模的数据排序.

归并排序 : 分治思想, 递归实现. 非原地排序, 稳定, O(NlogN), 空间O(N)

快速排序 : 分治思想, 递归实现. 原地排序, 不稳定, O(NlogN)

### 桶排序 | 计数排序 | 基数排序

这三个排序, 都是非原地排序.

桶排序 : N 个数, M 个桶, 时间复杂度为 O(N * log(N / M)) 当 M ≈ N 时, 时间复杂度接近于 O(N).

计数排序 : 数据范围内所有数据都准备一个桶, 特殊的桶排序

基数排序 : 时间复杂度为 O(k * N)

## 优化

快速排序

-   三数取中法 : 首, 尾, 中三个元素, 取中间大小的元素作为分区点.
-   随机法 : 随机选取元素作为分区点.
-   避免堆栈溢出 : 1. 限制递归深度, 超出阈值就停止递归; 2. 在堆上模拟实现一个函数调用栈, 手动模拟压栈和出栈的过程, 没有了系统栈大小的限制.

---

# 15 16 | 二分查找

## 主题 : 快速查找

------

## 二分查找

时间复杂度 : O(logN)

对数时间复杂度有时候要比常数时间复杂度还要高效, 42亿数据的二分需要32次, 而O(1)有时候代表的是O(1000)

二分代码结构 :

```cpp
int left = 0, right = nums.size() - 1;

while(left <= right){
	int mid = left + ((right - left) >> 1);
	if(nums[mid] > target)
		right = mid - 1;
	else if(nums[mid] < target)
		left = mid + 1;
	else
		return mid;
}
	return -1;
```

### 二分查找的适用场合 :

1.  顺序结构, 数组
2.  有序数据
3.  数据量不能太小, 比如10个, 是否使用影响不大
4.  数据量不能太大, 1GB的数据, 需要内存连续, 要求有点高

### 四种常见的二分查找变形问题 :

1.  查找第一个值等于给定值的元素
2.  查找最后一个值等于给定值的元素
3.  查找第一个大于等于给定值的元素
4.  查找最后一个小于等于给定值的元素

**第一个问题和第二个问题 :**

采用这样的方式, 就可以轻松判断而且很好理解

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> res(2, -1);
        int left = 0, right = nums.size() - 1;
        while(left <= right){
            int mid = left + ((right - left) >> 1);
            if(nums[mid] > target)  right = mid - 1;
            else if(nums[mid] < target) left = mid + 1;
            else{
                if(mid == 0 || nums[mid - 1] != target) {
                    res[0] = mid;
                    break;
                }
                right = mid - 1;
            }
        }
        left = 0, right = nums.size() - 1;
        while(left <= right){
            int mid = left + ((right - left) >> 1);
            if(nums[mid] > target)  right = mid - 1;
            else if(nums[mid] < target) left = mid + 1;
            else{
                if(mid == nums.size() - 1 || nums[mid+1] != target) {
                    res[1] = mid;
                    break;
                }
                left = mid + 1;
            }
        }
        return res;
    }
};
```

**第三个问题**

```cpp
int left = 0, right = nums.size() - 1;
        while(left <= right){
            int mid = left + ((right - left) >> 1);
            if(nums[mid] >= target){
                if(mid == 0 || nums[mid - 1] < target)  return mid;
                else right = mid - 1;
            } else
                left = mid + 1;
        }
```

**第四个问题类似于第三个问题**

```cpp
int left = 0, right = nums.size() - 1;
        while(left <= right){
            int mid = left + ((right - left) >> 1);
            if(nums[mid] > target){
                right = mid - 1;
            } else{
                if(mid == nums.size() - 1 || nums[mid + 1] > target)    return mid;
                else    left = mid + 1;
            }
        }
```

----

# 17 | 跳表

## 主题 : 为什么 Redis 一定要用跳表来实现有序集合?

Redis核心操作 :

-   插入一个数据
-   删除一个数据
-   查找一个数据
-   按照区间查找数据
-   迭代输出有序序列

红黑树的话, 第四个操作效率不高, 而且跳表的代码实现相较于红黑树来说简单, 不容易出错, 更为灵活, 能够改变索引构建策略, 有效地平衡执行效率和内存消耗.

------

## 跳表

前文提到, 二分查找只适用于数组, 而不适用于链表, 但是对链表稍加改造就可以使它适用于二分查找.

改进后的数据结构就是跳表.

链表上增加多级索引, 能够快速定位到某个节点.

查询的时间复杂度 O(logN)

以空间换取时间, 实现在链表上的快速查找, 空间复杂度 O(N)

插入和删除时间复杂度 O(logN)

但是, 插入删除操作过多的话, 会导致两个索引之间存在大量节点, 会退化成单链表, 因此也需要动态更新.

类似于, 红黑树, AVL有调整规则, 跳表的调整策略是 : 随机函数.

随机函数计算某个值, 那么把 key 加入到 第一层至第k层索引层上.